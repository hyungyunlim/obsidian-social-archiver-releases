/**
 * CrawlJobTracker - Centralized state management for active profile crawl jobs
 *
 * Provides reactive updates for profile crawl progress tracking with:
 * - In-memory job state management (no localStorage - relies on PendingJobsManager for persistence)
 * - Observer pattern for UI updates
 * - Auto-cleanup of completed jobs after 5 seconds
 * - WebSocket event matching via workerJobId mapping
 * - App restart recovery via restoreFromPendingJobs()
 *
 * Usage:
 * ```typescript
 * // Start a crawl job
 * crawlJobTracker.startJob({
 *   jobId: 'internal-uuid',
 *   handle: '@username',
 *   platform: 'instagram',
 *   estimatedPosts: 20,
 * }, 'worker-job-id');
 *
 * // Update progress from WebSocket events
 * crawlJobTracker.incrementProgressByWorkerJobId('worker-job-id');
 *
 * // Complete the job
 * crawlJobTracker.completeJob('internal-uuid', 15);
 *
 * // Subscribe to updates
 * const unsubscribe = crawlJobTracker.onUpdate((jobs) => {
 *   // Update UI with current jobs
 * });
 * ```
 */

import type { Platform } from '../types/post';
import type { PendingJob } from './PendingJobsManager';

// ============================================================================
// Types
// ============================================================================

/**
 * Active crawl job state for UI display
 */
export interface ActiveCrawlJob {
  /** Internal job ID (generated by plugin) */
  jobId: string;

  /** Profile handle (e.g., '@username' or 'username') */
  handle: string;

  /** Platform being crawled */
  platform: Platform;

  /** Estimated number of posts to crawl */
  estimatedPosts: number;

  /** Number of posts received so far */
  receivedPosts: number;

  /** Job start timestamp */
  startedAt: number;

  /** Current job status */
  status: 'crawling' | 'completed' | 'failed';

  /** Error message if status is 'failed' */
  error?: string;
}

/**
 * Callback type for job updates
 */
export type CrawlJobUpdateCallback = (jobs: ActiveCrawlJob[]) => void;

// ============================================================================
// CrawlJobTracker Service
// ============================================================================

/**
 * Centralized state management for active profile crawl jobs
 */
export class CrawlJobTracker {
  /** Active jobs indexed by internal job ID */
  private jobs: Map<string, ActiveCrawlJob> = new Map();

  /** Listeners for job updates */
  private listeners: Set<CrawlJobUpdateCallback> = new Set();

  /** Timers for auto-cleanup of completed jobs */
  private completionTimers: Map<string, ReturnType<typeof setTimeout>> = new Map();

  /** Map workerJobId -> internal jobId for WebSocket event matching after restart */
  private workerJobIdMap: Map<string, string> = new Map();

  // --------------------------------------------------------------------------
  // Job Lifecycle Methods
  // --------------------------------------------------------------------------

  /**
   * Start tracking a new crawl job
   *
   * @param job - Job configuration (without receivedPosts, startedAt, status)
   * @param workerJobId - Optional Worker job ID for WebSocket event matching
   */
  startJob(
    job: Omit<ActiveCrawlJob, 'receivedPosts' | 'startedAt' | 'status'>,
    workerJobId?: string
  ): void {
    const activeJob: ActiveCrawlJob = {
      ...job,
      receivedPosts: 0,
      startedAt: Date.now(),
      status: 'crawling',
    };

    this.jobs.set(job.jobId, activeJob);

    // Map workerJobId for WebSocket event matching
    if (workerJobId) {
      this.workerJobIdMap.set(workerJobId, job.jobId);
    }

    this.notifyListeners();
  }

  /**
   * Restore active crawl jobs from PendingJobsManager on app startup.
   * Filters for profile-crawl jobs that are still processing.
   *
   * @param pendingJobs - Array of pending jobs from PendingJobsManager
   */
  restoreFromPendingJobs(pendingJobs: PendingJob[]): void {
    for (const job of pendingJobs) {
      // Only restore profile-crawl jobs that are still processing
      if (job.metadata?.type !== 'profile-crawl' || job.status !== 'processing') {
        continue;
      }

      const activeJob: ActiveCrawlJob = {
        jobId: job.id,
        handle: job.metadata.handle || 'unknown',
        platform: job.platform,
        estimatedPosts: job.metadata.estimatedPosts || 0,
        receivedPosts: 0, // Reset to 0 - will be updated via WebSocket
        startedAt: job.metadata.startedAt || job.timestamp,
        status: 'crawling',
      };

      this.jobs.set(job.id, activeJob);

      // Map workerJobId for WebSocket event matching
      if (job.metadata.workerJobId) {
        this.workerJobIdMap.set(job.metadata.workerJobId, job.id);
      }
    }

    if (this.jobs.size > 0) {
      this.notifyListeners();
    }
  }

  /**
   * Increment progress for a job by internal job ID
   *
   * @param jobId - Internal job ID
   */
  incrementProgress(jobId: string): void {
    const job = this.jobs.get(jobId);
    if (job && job.status === 'crawling') {
      job.receivedPosts++;
      this.notifyListeners();
    }
  }

  /**
   * Increment progress by Worker job ID (useful for WebSocket events)
   *
   * @param workerJobId - Worker job ID from WebSocket event
   * @returns true if job found and incremented, false otherwise
   */
  incrementProgressByWorkerJobId(workerJobId: string): boolean {
    const job = this.getJobByWorkerJobId(workerJobId);
    if (job && job.status === 'crawling') {
      job.receivedPosts++;
      this.notifyListeners();
      return true;
    }
    return false;
  }

  /**
   * Mark a job as completed
   *
   * @param jobId - Internal job ID
   * @param finalCount - Final number of posts archived
   */
  completeJob(jobId: string, finalCount: number): void {
    const job = this.jobs.get(jobId);
    if (job) {
      job.status = 'completed';
      job.receivedPosts = finalCount;
      this.notifyListeners();

      // Auto-hide after 5 seconds
      const timer = setTimeout(() => {
        this.removeJobInternal(jobId);
      }, 5000);

      this.completionTimers.set(jobId, timer);
    }
  }

  /**
   * Mark a job as failed
   *
   * @param jobId - Internal job ID
   * @param error - Error message
   */
  failJob(jobId: string, error: string): void {
    const job = this.jobs.get(jobId);
    if (job) {
      job.status = 'failed';
      job.error = error;
      this.notifyListeners();
    }
  }

  /**
   * Manually dismiss a job (user clicks close button)
   *
   * @param jobId - Internal job ID
   */
  dismissJob(jobId: string): void {
    // Clear any pending completion timer
    const timer = this.completionTimers.get(jobId);
    if (timer) {
      clearTimeout(timer);
      this.completionTimers.delete(jobId);
    }

    this.removeJobInternal(jobId);
  }

  // --------------------------------------------------------------------------
  // Query Methods
  // --------------------------------------------------------------------------

  /**
   * Get all active jobs
   *
   * @returns Array of active crawl jobs
   */
  getActiveJobs(): ActiveCrawlJob[] {
    return Array.from(this.jobs.values());
  }

  /**
   * Get a specific job by internal ID
   *
   * @param jobId - Internal job ID
   * @returns ActiveCrawlJob or undefined
   */
  getJob(jobId: string): ActiveCrawlJob | undefined {
    return this.jobs.get(jobId);
  }

  /**
   * Get job by Worker job ID (for WebSocket event matching after restart)
   *
   * @param workerJobId - Worker job ID
   * @returns ActiveCrawlJob or undefined
   */
  getJobByWorkerJobId(workerJobId: string): ActiveCrawlJob | undefined {
    const internalJobId = this.workerJobIdMap.get(workerJobId);
    if (internalJobId) {
      return this.jobs.get(internalJobId);
    }
    return undefined;
  }

  /**
   * Get internal job ID from worker job ID
   *
   * @param workerJobId - Worker job ID
   * @returns Internal job ID or undefined
   */
  getInternalJobIdByWorkerJobId(workerJobId: string): string | undefined {
    return this.workerJobIdMap.get(workerJobId);
  }

  /**
   * Get all active jobs
   *
   * @returns Array of all active jobs
   */
  getAllJobs(): ActiveCrawlJob[] {
    return Array.from(this.jobs.values());
  }

  /**
   * Check if there are any active (crawling) jobs
   *
   * @returns true if any jobs are in 'crawling' status
   */
  hasActiveJobs(): boolean {
    for (const job of this.jobs.values()) {
      if (job.status === 'crawling') {
        return true;
      }
    }
    return false;
  }

  // --------------------------------------------------------------------------
  // Observer Pattern
  // --------------------------------------------------------------------------

  /**
   * Subscribe to job updates
   *
   * @param callback - Function called when jobs change
   * @returns Unsubscribe function
   */
  onUpdate(callback: CrawlJobUpdateCallback): () => void {
    this.listeners.add(callback);
    return () => {
      this.listeners.delete(callback);
    };
  }

  // --------------------------------------------------------------------------
  // Cleanup
  // --------------------------------------------------------------------------

  /**
   * Dispose of the tracker and clean up resources
   */
  dispose(): void {
    // Clear all completion timers
    this.completionTimers.forEach((timer) => clearTimeout(timer));
    this.completionTimers.clear();

    // Clear all state
    this.jobs.clear();
    this.listeners.clear();
    this.workerJobIdMap.clear();
  }

  // --------------------------------------------------------------------------
  // Private Helpers
  // --------------------------------------------------------------------------

  /**
   * Remove a job and clean up associated state
   */
  private removeJobInternal(jobId: string): void {
    this.jobs.delete(jobId);
    this.completionTimers.delete(jobId);

    // Clean up workerJobId mapping
    for (const [wjid, jid] of this.workerJobIdMap.entries()) {
      if (jid === jobId) {
        this.workerJobIdMap.delete(wjid);
        break;
      }
    }

    this.notifyListeners();
  }

  /**
   * Notify all listeners of state change
   */
  private notifyListeners(): void {
    const jobs = this.getActiveJobs();
    this.listeners.forEach((callback) => callback(jobs));
  }
}
