/**
 * ArchiveJobTracker - Centralized state management for active post archive jobs
 *
 * Provides reactive updates for archive progress tracking with:
 * - In-memory job state management (no localStorage - relies on PendingJobsManager for persistence)
 * - Observer pattern for UI updates
 * - Auto-cleanup of completed jobs after 5 seconds
 * - WebSocket event matching via workerJobId mapping
 * - App restart recovery via restoreFromPendingJobs()
 *
 * Usage:
 * ```typescript
 * // Start an archive job
 * archiveJobTracker.startJob({
 *   jobId: 'internal-uuid',
 *   url: 'https://x.com/user/status/123',
 *   platform: 'x',
 * });
 *
 * // Update progress from WebSocket events
 * archiveJobTracker.markProcessing('internal-uuid', 'worker-job-id');
 *
 * // Complete the job
 * archiveJobTracker.completeJob('internal-uuid');
 *
 * // Subscribe to updates
 * const unsubscribe = archiveJobTracker.onUpdate((jobs) => {
 *   // Update UI with current jobs
 * });
 * ```
 */

import type { Platform } from '../shared/platforms/types';
import type { PendingJob } from './PendingJobsManager';

// ============================================================================
// Types
// ============================================================================

/**
 * Archive banner status for UI display
 */
export type ArchiveBannerStatus =
  | 'queued'
  | 'archiving'
  | 'retrying'
  | 'completed'
  | 'failed';

/**
 * Active archive job state for UI display
 */
export interface ActiveArchiveJob {
  /** Internal job ID (generated by plugin) */
  jobId: string;

  /** Worker job ID for WebSocket event matching */
  workerJobId?: string;

  /** URL being archived */
  url: string;

  /** Platform being archived */
  platform: Platform;

  /** Current job status */
  status: ArchiveBannerStatus;

  /** Job start timestamp */
  startedAt: number;

  /** Last update timestamp */
  updatedAt: number;

  /** Number of retry attempts */
  retryCount: number;

  /** Maximum retry attempts (V1: 3) */
  maxRetries: number;

  /** Progress text for long-running operations (e.g., Naver Webtoon) */
  progressText?: string;

  /** Error message if status is 'failed' */
  error?: string;
}

/**
 * Callback type for job updates
 */
export type ArchiveJobUpdateCallback = (jobs: ActiveArchiveJob[]) => void;

// ============================================================================
// ArchiveJobTracker Service
// ============================================================================

/**
 * Centralized state management for active post archive jobs
 */
export class ArchiveJobTracker {
  /** Active jobs indexed by internal job ID */
  private jobs: Map<string, ActiveArchiveJob> = new Map();

  /** Listeners for job updates */
  private listeners: Set<ArchiveJobUpdateCallback> = new Set();

  /** Timers for auto-cleanup of completed jobs */
  private completionTimers: Map<string, ReturnType<typeof setTimeout>> = new Map();

  /** Map workerJobId -> internal jobId for WebSocket event matching */
  private workerJobIdMap: Map<string, string> = new Map();

  // --------------------------------------------------------------------------
  // Job Lifecycle Methods
  // --------------------------------------------------------------------------

  /**
   * Start tracking a new archive job
   *
   * @param input - Job configuration
   */
  startJob(input: {
    jobId: string;
    url: string;
    platform: Platform;
    maxRetries?: number;
  }): void {
    const activeJob: ActiveArchiveJob = {
      jobId: input.jobId,
      url: input.url,
      platform: input.platform,
      status: 'queued',
      startedAt: Date.now(),
      updatedAt: Date.now(),
      retryCount: 0,
      maxRetries: input.maxRetries ?? 3, // V1: default 3 retries
    };

    this.jobs.set(input.jobId, activeJob);
    this.notifyListeners();
  }

  /**
   * Mark a job as processing (archiving)
   *
   * @param jobId - Internal job ID
   * @param workerJobId - Optional Worker job ID for WebSocket event matching
   */
  markProcessing(jobId: string, workerJobId?: string): void {
    const job = this.jobs.get(jobId);
    if (job) {
      job.status = 'archiving';
      job.updatedAt = Date.now();

      if (workerJobId) {
        job.workerJobId = workerJobId;
        this.workerJobIdMap.set(workerJobId, jobId);
      }

      this.notifyListeners();
    }
  }

  /**
   * Update progress text for a job
   *
   * @param jobId - Internal job ID
   * @param progressText - Progress message (e.g., "Downloading episode 1/10")
   */
  updateProgress(jobId: string, progressText: string): void {
    const job = this.jobs.get(jobId);
    if (job) {
      job.progressText = progressText;
      job.updatedAt = Date.now();
      this.notifyListeners();
    }
  }

  /**
   * Mark a job as retrying
   *
   * @param jobId - Internal job ID
   * @param retryCount - Current retry attempt number
   */
  markRetrying(jobId: string, retryCount: number): void {
    const job = this.jobs.get(jobId);
    if (job) {
      job.status = 'retrying';
      job.retryCount = retryCount;
      job.updatedAt = Date.now();
      this.notifyListeners();
    }
  }

  /**
   * Mark a job as completed
   * Auto-hides after 5 seconds
   *
   * @param jobId - Internal job ID
   */
  completeJob(jobId: string): void {
    const job = this.jobs.get(jobId);
    if (job) {
      job.status = 'completed';
      job.updatedAt = Date.now();
      this.notifyListeners();

      // Auto-hide after 5 seconds
      const timer = setTimeout(() => {
        this.removeJobInternal(jobId);
      }, 5000);

      this.completionTimers.set(jobId, timer);
    }
  }

  /**
   * Mark a job as failed
   *
   * @param jobId - Internal job ID
   * @param error - Error message
   */
  failJob(jobId: string, error: string): void {
    const job = this.jobs.get(jobId);
    if (job) {
      job.status = 'failed';
      job.error = error;
      job.updatedAt = Date.now();
      this.notifyListeners();
    }
  }

  /**
   * Manually dismiss a job (user clicks close button)
   *
   * @param jobId - Internal job ID
   */
  dismissJob(jobId: string): void {
    // Clear any pending completion timer
    const timer = this.completionTimers.get(jobId);
    if (timer) {
      clearTimeout(timer);
      this.completionTimers.delete(jobId);
    }

    this.removeJobInternal(jobId);
  }

  /**
   * Restore active archive jobs from PendingJobsManager on app startup.
   * Filters for post-archive jobs that are pending/processing/failed.
   *
   * @param pendingJobs - Array of pending jobs from PendingJobsManager
   */
  restoreFromPendingJobs(pendingJobs: PendingJob[]): void {
    for (const job of pendingJobs) {
      // Skip profile-crawl jobs (those are handled by CrawlJobTracker)
      if (job.metadata?.type === 'profile-crawl') {
        continue;
      }

      // Skip completed/cancelled jobs
      if (job.status === 'completed' || job.status === 'cancelled') {
        continue;
      }

      // Restore as active archive job
      const status: ArchiveBannerStatus =
        job.status === 'processing' ? 'archiving' :
        job.status === 'failed' ? 'failed' :
        'queued';

      const activeJob: ActiveArchiveJob = {
        jobId: job.id,
        workerJobId: job.metadata?.workerJobId,
        url: job.url,
        platform: job.platform,
        status,
        startedAt: job.metadata?.startedAt || job.timestamp,
        updatedAt: Date.now(),
        retryCount: job.retryCount,
        maxRetries: 3, // V1: default
        error: job.metadata?.lastError,
      };

      this.jobs.set(job.id, activeJob);

      // Map workerJobId for WebSocket event matching
      if (job.metadata?.workerJobId) {
        this.workerJobIdMap.set(job.metadata.workerJobId, job.id);
      }
    }

    if (this.jobs.size > 0) {
      this.notifyListeners();
    }
  }

  // --------------------------------------------------------------------------
  // Query Methods
  // --------------------------------------------------------------------------

  /**
   * Get all active jobs, sorted by startedAt descending (newest first)
   *
   * @returns Array of active archive jobs
   */
  getActiveJobs(): ActiveArchiveJob[] {
    return Array.from(this.jobs.values()).sort(
      (a, b) => b.startedAt - a.startedAt
    );
  }

  /**
   * Get a specific job by internal ID
   *
   * @param jobId - Internal job ID
   * @returns ActiveArchiveJob or undefined
   */
  getJob(jobId: string): ActiveArchiveJob | undefined {
    return this.jobs.get(jobId);
  }

  /**
   * Get job by Worker job ID (for WebSocket event matching)
   *
   * @param workerJobId - Worker job ID
   * @returns ActiveArchiveJob or undefined
   */
  getJobByWorkerJobId(workerJobId: string): ActiveArchiveJob | undefined {
    const internalJobId = this.workerJobIdMap.get(workerJobId);
    if (internalJobId) {
      return this.jobs.get(internalJobId);
    }
    return undefined;
  }

  // --------------------------------------------------------------------------
  // Observer Pattern
  // --------------------------------------------------------------------------

  /**
   * Subscribe to job updates
   *
   * @param callback - Function called when jobs change
   * @returns Unsubscribe function
   */
  onUpdate(callback: ArchiveJobUpdateCallback): () => void {
    this.listeners.add(callback);
    return () => {
      this.listeners.delete(callback);
    };
  }

  // --------------------------------------------------------------------------
  // Cleanup
  // --------------------------------------------------------------------------

  /**
   * Destroy the tracker and clean up all resources
   */
  destroy(): void {
    // Clear all completion timers
    this.completionTimers.forEach((timer) => clearTimeout(timer));
    this.completionTimers.clear();

    // Clear all state
    this.jobs.clear();
    this.listeners.clear();
    this.workerJobIdMap.clear();
  }

  // --------------------------------------------------------------------------
  // Private Helpers
  // --------------------------------------------------------------------------

  /**
   * Remove a job and clean up associated state
   */
  private removeJobInternal(jobId: string): void {
    this.jobs.delete(jobId);
    this.completionTimers.delete(jobId);

    // Clean up workerJobId mapping
    for (const [wjid, jid] of this.workerJobIdMap.entries()) {
      if (jid === jobId) {
        this.workerJobIdMap.delete(wjid);
        break;
      }
    }

    this.notifyListeners();
  }

  /**
   * Notify all listeners of state change
   */
  private notifyListeners(): void {
    const jobs = this.getActiveJobs();
    this.listeners.forEach((callback) => callback(jobs));
  }
}
